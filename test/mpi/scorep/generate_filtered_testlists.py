"""
Traverse a directory structure recursively,
look for testlist files,
and write out filtered testlist files.

The preferred method to disable/enable entire test groups should be by setting appropriate configure options
for the test suite (in scorep/configure-for-scorep.sh).
Look at the output of configure --help for a list of some options.

This script is helps to remove individual tests from the suite that are expected to fail when run with Score-P.
For example, if the test calls MPI functions that are not supported by Score-P.

Algorithm:
0. Current directory = working directory.
1. Open 'testlist' in the current directory.
2. For each test listed in the 'testlist' file, see if there is any reason to exclude it.
3. Write 'testlist.filtered', containing:
   - all subdirectories listed in 'testlist'
   - all tests which were not excluded in 2.
4. For each directory listed in 'testlist' set the current directory and apply 1.

Exclusion filters can read from a json file (See testlist-exlude-patterns.json).
The json should specify a dictionary with {place:patterns}
place: place / context to apply exclude patterns
patterns: a list of regular expression patterns to apply

The regexes use the syntax from the re module.
Take care to escape properly.

Warning: The discovery of source files for executables relies on the Makefile in each subdirectory and assumes a
simple Makefile structure.
"""

import argparse
import os
import re
import json

from python_utils.read_sources_from_makefile import read_sources_from_makefile
from python_utils.default_logger import set_default_logging_behavior
from python_utils.strip_comments_from_json import strip_comments

import logging
logger = logging.getLogger(__name__)


def read_subdirs_and_tests(dirpath, testlist_in):
    testlist_subdirs = []
    testlist_tests = []
    with open(testlist_in, 'r') as file:
        for line in file:
            line = line.strip()
            # comment: skip
            if re.match(r'^\s*#', line):
                continue
            # test of the form 'executable num_processes extra_args'
            m = re.match(r'^(\w+)\s+\d+', line)
            if m:
                testlist_tests.append({'exe': m.group(1), 'line': line})
                continue
            # subdirectory
            if os.path.isdir(os.path.join(dirpath, line)):
                testlist_subdirs.append(line)
        return testlist_subdirs, testlist_tests


def write_testlist(testlist_out, subdirs, tests):
    logger.debug("Writing '%s'", testlist_out)
    with open(testlist_out, 'w') as out:
        out.write("# Autogenerated by {}\n".format(__file__))
        for line in subdirs:
            out.write(line)
            out.write('\n')
        for line in tests:
            out.write(line)
            out.write('\n')


def exclude_test(test, dirpath, exe_to_sources, exclude_patterns):
    exe_path = os.path.join(dirpath, test['exe'])
    for pattern in exclude_patterns['exe-name']:
        if re.search(pattern, exe_path):
            logger.debug("Excluding test '%s' because its name matches r'%s'", exe_path, pattern)
            return True

    for pattern in exclude_patterns['list-entry']:
        if re.search(pattern, test['line']):
            logger.debug("Excluding test '%s' because its testlist entry '%s' matches r'%s'",
                         exe_path, test['line'], pattern)
            return True

    if test['exe'] not in exe_to_sources:
        logger.debug("No source file is associated with '%s'", exe_path)
        return False

    for source in exe_to_sources[test['exe']]:
        source_path = os.path.join(dirpath, source)
        for pattern in exclude_patterns['source-name']:
            if re.search(pattern, source_path):
                logger.debug("Excluding test '%s' because the name of its source '%s' matches r'%s'",
                             exe_path, source_path, pattern)
                return True
        if exclude_source(source_path, exclude_patterns['source-contents']):
            logger.debug("Excluding test %s because of the contents of its source '%s'", exe_path, source_path)
            return True

    return False


def exclude_source(source, exclude_patterns):
    if not os.path.isfile(source):
        logger.debug("The source file '%s' could not be found", source)
        return False

    with open(source, 'r') as file:
        for line_no, line in enumerate(file):
            for pattern in exclude_patterns:
                if re.search(pattern, line):
                    logger.debug("Exclude criterion in '%s': Line '%s' matches '%s'", source, line_no, pattern)
                    return True
    return False


default_exclude_patterns = {
    'exe-name': [],  # Apply patterns to the path of the test executable relative to the working directory
    'list-entry': [],  # Apply patterns to the entire line in the source testlist
    'source-name': [],  # Apply patterns to the names of all source files of the test
    'source-contents': [],  # Apply patterns to each line of each source file of the test
}


if __name__ == '__main__':
    set_default_logging_behavior(logfile='generate_filtered_tests', root_name=__name__)

    parser = argparse.ArgumentParser()
    parser.add_argument('--testlist-in', '-i', default='testlist')
    parser.add_argument('--testlist-out', '-o', default='testlist.filtered')
    parser.add_argument('--filter', '-f')
    args = parser.parse_args()

    assert args.testlist_in != args.testlist_out

    num_tests = 0
    num_tests_included = 0

    exclude_patterns = {}
    if args.filter is not None and os.path.isfile(args.filter):
        logger.info("Loading filter file '%s'", args.filter)
        with open(args.filter) as file:
            exclude_patterns = json.load(file)
    else:
        exclude_patterns = default_exclude_patterns

    exclude_patterns = strip_comments(exclude_patterns)
    assert sorted(['exe-name', 'list-entry', 'source-name', 'source-contents']) == sorted(exclude_patterns.keys()),\
        "The loaded filter file is invalid"
    logger.debug("Exclude patterns = %s", exclude_patterns)

    for dirpath, dirnames, filenames in os.walk('.', topdown=True):
        logger.info("Processing directory '%s'", dirpath)

        testlist_in = os.path.join(dirpath, args.testlist_in)
        if not os.path.isfile(testlist_in):
            dirnames[:] = []  # Do not progress further into subdirs
            continue

        testlist_subdirs, testlist_tests = read_subdirs_and_tests(dirpath, testlist_in)

        # Only recurse into those subdirectories that are part of the testlist
        dirnames[:] = [d for d in dirnames if d in testlist_subdirs]

        # Filter tests
        makefile = os.path.join(dirpath, 'Makefile')
        sources = {}
        if os.path.isfile(makefile):
            sources = read_sources_from_makefile(makefile)

        filtered_tests = [test['line']
                          for test in testlist_tests
                          if not exclude_test(test, dirpath, sources, exclude_patterns)]

        num_tests += len(testlist_tests)
        num_tests_included += len(filtered_tests)

        # Write new testlist
        testlist_out = os.path.join(dirpath, args.testlist_out)
        write_testlist(testlist_out, testlist_subdirs, filtered_tests)

    logger.info("Discovered %s tests in total", num_tests)
    logger.info("Retained %s tests", num_tests_included)
    logger.info("Discarded %s tests", num_tests - num_tests_included)
